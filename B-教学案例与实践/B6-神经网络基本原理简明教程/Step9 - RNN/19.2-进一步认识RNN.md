<!--Copyright © Microsoft Corporation. All rights reserved.
  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可-->

## 19.2 进一步认识RNN


### 19.2.1 提出问题

在加减法运算中，总会遇到进位或者退位的问题，我们以二进制为例，比如13-5=8这个十进制的减法，变成二进制后如下所示：

```
13 - 6 = 7
====================
  x1: [1, 1, 0, 1]
- x2: [0, 1, 1, 0]
------------------
  y:  [0, 1, 1, 1]
====================
```
- 被减数13变成了[1, 1, 0, 1]
- 减数6变成了[0, 1, 1, 0]
- 结果的7变成了[0, 1, 1, 1]

在减法过程中：
- x1和x2的最后一位是1和0，相减为1
- 倒数第二位是0和1，需要从前面借一位，相减后得1
- 倒数第三位本来是1和1，借位后变成了0和1，再从前面借一位，相减后得1
- 倒数第四位现在是0和0，相减为0

也就是说，在减法过程中，后面的计算会影响前面的值，所以必须逐位计算，这也就是序列的概念，所以应该可以用RNN的技术来解决。

由于计算是从最后一位开始的，我们认为最后一位是第一个时间步，所以需要把样本数据的前后顺序颠倒一下，比如13，从二进制的 [1, 1, 0, 1] 倒序变成 [1, 0, 1, 1]。相应地，标签数据7也要从二进制的 [0, 1, 1, 1] 倒序变成 [1, 1, 1, 0]。

在这里个例子中，因为是4位二进制减法，所以最大值是15，即 [1, 1, 1, 1]，最小值是0，并且要求被减数必须大于减数，所以样本的数量一共是136个，每个样本含有两组4位的二进制数，表示被减数和减数。标签值为一组4位二进制数。三组二进制数都是倒叙。


在本例中，我们仍然从DNN的结构扩展到含有4个时序的网络结构：

<img src="../Images/19/binary_number_minus_net.png" width="600" />
<img src="../Images/19/binary_number_minus_unfold.png" width="600" />


上图中，最左侧的简易结构是通常的RNN的画法，而右侧是其展开后的细节，由此可见细节有很多，如果不展开的话，对于初学者来说很难理解，而且也不利于我们进行反向传播的推导。


下面是最后几轮的打印输出结果：

```
...
11 1525
loss=0.087381, acc=0.977941
...
loss=0.081522, acc=1.000000
testing...
loss=0.080641, acc=1.000000
```

下面随机列出了几个测试样本及其预测结果：

```
  x1: [1, 0, 1, 1]
- x2: [0, 0, 0, 1]
------------------
true: [1, 0, 1, 0]
pred: [1, 0, 1, 0]
11 - 1 = 10
====================

  x1: [1, 1, 1, 1]
- x2: [0, 0, 1, 1]
------------------
true: [1, 1, 0, 0]
pred: [1, 1, 0, 0]
15 - 3 = 12
====================

  x1: [1, 1, 0, 1]
- x2: [0, 1, 1, 0]
------------------
true: [0, 1, 1, 1]
pred: [0, 1, 1, 1]
13 - 5 = 8
====================
```